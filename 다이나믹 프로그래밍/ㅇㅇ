다이나믹 프로그래밍은 메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법
이미 계산된 결과(작은 문제)는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 한다.
다이나믹 프로그래밍의 구현은 바텀업, 탑다운 방식으로 구성된다

다음 조건 만족시 DP사용 가능
1. 최적 부분 구조
    - 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아 큰 문제의 답 얻을 수 있을 경우
2. 중복되는 부분 문제
    - 동일한 작은 문제를 반복적으로 해결해야 한다.

ex
피보나치 수열
점화식이란 인접한 항들 사이의 관계식을 의미한다.
피보나치 시간 복잡도 : O(2^n)
fib(6)을 구하 려면 fib(2)가 여러 번 호출된다 - 중복되는 부분 문제
fib(30)을 구하려면 약 10억 가량의 연산이 필요하다.

피보나치수는 최적 부분 구조, 중복되는 부분 문제를 가짐 - DP사용 가능

탑다운 방식 : 메모이제이션
한 번 계산한 결과를 메모리 공간에 메모하는 기법
    같은 문제 다시 호출시 메모했던 결과를 가져옴
    값을 기록해 놓는다는 점에서 캐싱(Caching)이라고도 한다.
메모이제이션은 이전 계산 결과를 일시적으로 기록해 놓은 넓은 개념을 의미한다.
    따라서 메모이제이션은 DP에 국한된 개념은 아니다.
    한 번 계산된 결과를 담아 놓기만 하고 DP를 위해 활용하지 않을 수도 있다.

바텀업 방식 : 
결과 저장용 리스트를 DP테이블이라고 부른다.



DP vs 분할 정복
DP, 분할 정복은 모두 최적 부분 구조를 가질 때 사용 가능하다.
차이점은 부분 문제의 중복이다.
    DP에서는 각 문제들이 서로 영향을 미치며 부분 문제가 중복된다.
    분할 정복 문제에서는 동일한 문제가 반복적으로 계산되지 않는다.
     ex 퀵정렬 - 한번 피봇의 자리를 변경해서 자리를 잡으면 그 기준 원소의 위치는 바뀌지 않는다.
        분할 이후에 해당 피봇을 다시 처리하는 부분 문제는 호출되지 않는다.

* DP문제에 접근하는 방법
주어진 문제가 DP유형임을 파악하는 것이 중요.
먼저 그리디, 구현, 완전 탐색 등의 아이디어로 해결 가능한지 검토
    다른 알고리즘으로 방법이 떠오르지 않으면 DP 고려한다.
일단 재귀 함수로 비효율적인 완전 탐색 프로그램을 작성한 뒤 (탑다운) 작은 문제에서 구한 답이 큰 문제에서
그대로 적용 가능하면 코드를 개선하는 방법을 사용할 수 잇다.
일반적인 코테 수준에서는 기본 유형의 DP가 출제되는 경우가 많다.